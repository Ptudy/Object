오브젝트 정리(1~3장)

1장 객체, 설계

소프트웨어 모듈이 가져야하는 세가지 기능 로버트 마틴 클린소프트웨어 애자일 원칙과 패턴, 그리고 실천방법
-1 요구사항을 제대로 구현하는것
-2 모듈은 생명주기동안 반드시 변경되므로(그리스 철학자 헤라이클레이토스는 우주에서 변하지 않는것은 변하지 않는다는 사실뿐) 간단한 작업만으로도 변경이 가능해야함
-3 코드를 읽는 사람과 의사소통하는것(읽는 사람과 의사소통할수 없는 모듈은 잘못된 모듈) - 클린코드 원칙

Step1.




Theater 객체가 모든것을 통제하는 설계

문제점은 크게 2가지

Theater 중심의 절차지향적 설계 - 변경에 취약

uml에서 표현하는 연관관계(실선)로든, 의존관계로든(점선) Theater객체는 많은 다른 객체를 의존하고 있으며, 이는 결합도가 높은 코드로 변경에 취약함

불필요한 의존성이 없는지 검토할 필요가 있음

역할과 책임의 분배가 잘 이루어 졌는가?

Theater가 너무 많은 일을 하고 있음


Theater가 가방에게 초대장을 달라고하는 메시지 전달하는 코드
 if(audience.getBag().hasInvitation())
과연 Theater가 가방에게 초대장을 달라는 메시지를 보낼 책임이 있는가? 등등


+ 디미터 법칙과 자료구조 접근

최종



Theater가 알고있는 의존관계가 줄고 

자신의 데이터를 스스로가 처리하도록 audience, ticketseller에게 책임을 분배하므로서 oop 설계를 실천

불필요한 의존관계가 몇개 줄기는 했지만 전체적인 의존관계의 수로 생각하면 사실 크게 축소된것은 아님

위의 설계와 아래 설계의 차이점은 바로 책임의 이동

절차적 프로그래밍 방식과 객체지향적 프로그래밍 방식의 차이이며

모든 책임이 Theater에 있는 설계와 책임이 분배되있는 설계

결국 설계란 책임의 분배

객체지향 설계란 객체에 책임을 분배하는 것, 더 raw하게는 코드를 분배하는것


클린코드에서는 oop를 신봉할 필요는 없다고 말함 객체지향 설계와 절차지향설계는 모두 장단이 있음

하지만 자바가 객체지향 패러다임을 근간으로 하고 있으며, 디폴트 메서드를 가진 인터페이스등 성숙한 oop 코드 작성에 유리하며, 협업관점에서도 oop적 코드가 강점이 많으므로

객체지향 설계를 지향하는것이 바람직하지 않나싶다

의존성을 효율적으로 통제할수 있는 다양한 방법을 제공하므로써 요구사항 변경에 좀더 수월하게 대응할수 있는 가능성!

객체간의 의존성은 애플리케이션을 수정하기 어렵게 만드는 주범(커플링)

데이터와 데이터에 해당하는 프로세스를 한덩어리로 모으고 객체들 사이의 의존성을 적절하게 조절하는것이 핵심



2장~3장  객체지향 프로그래밍 , 역할 책임 협력

영화 예매 시스템 예제로 설명

2장은 객체지향 프로그래밍을 구성하는 다양한 요소와 구현기법에 대해 코드로 설명함

협력, 객체, 클래스 
객체지향 설계에서 가장 먼저 고려할것은 클래스가 아니라 객체
어떤 객체들이 필요한지 고민할것
객체를 독립적인 존재가 아니라 기능을 구현하기위해 협력하는 공동체의 일원으로 생각할것

객체란 상태와 행동을 함게 가지는 복합적인 존재이며, 행동이 상태를 규정하는 사고방식이 중요하다고 저자는 주장

클래스 작성자와 클라이언트 프로그래머로 구분하기

내가 코드를 작성하는동안은 클래스 작성자이지만, 몇달이 지난후 해당 코드를 보거나, 협업하는 다른 팀원이 해당 코드를 보고 사용하게 될때믄 클라이언트 프로그래머다.

api를 만드는 관점도 똑같음

코드 작성자는 항상 내 코드가 인터페이스로서 클라이언트가 사용할수 있음을 인지하고, 내부의 구현과 인터페이스를 철저히 분리시켜 구현은 감추고, 이해하기 쉬운 인터페이스만 제공하는것이 바람직

인터페이스와 구현이 잘 분리되면, 클라이언트 프로그래머가 알아야할 지식의 양이 줄어들고 클래스 작성자가 자유롭게 구현을 변경할수 있는 폭이 넓어짐


추상클래스 인터페이스를 조합해 다향성을 구현하는 기본적인 방법

할인 정책과 할인 조건 구현에서 구체적인 policy대신 상위 추상화된 인터페이스에 의존하여 다향성 구현

상속의 오버라이딩을 통한 동적인 주입

동적 바인딩, 지연바인딩과 오버라이딩


composition over inheritance

상속보단 합성이 캡슐화 측면에서 더 좋은 방법



3장에서는 객체지향의 구현 기법들보다 중요한 객체지향 설계에서 고려할점


협력이란

1장에서 객체지향 설계는 객체들의 책임을 적절하게 분배하는것이라고 정의

이 책임이라는것은 어디에서 오는가?

요구사항 -> 요구사항을 충족하기위해 필요한 행동 = 어플리케이션의 책임

애플리케이션의 책임이 바로 협력이라는 문맥

이 거대한 책임(협력)을 이루기 위해 필요한 행동들이 바로 객체의 책임


책임이란

Crc 카드 기법

객체의 책임은 크게 하는것과 아는것으로 구분

책임은 해당 책임 행동을 하기에 필요한 정보들을 가진 정보전문가에게 분배되는것이 가장 바람직

따라서 책임을 할당하는데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 선택하자

그리고 메시지를 처리한 객체는 그 메시지에 따라 상태가 결정되게 된다.

책임주도 설계

시스템이 사용자에게 제공해야하는 기능인 시스템책임을 파악
시스템 책임을 더 작은 책임으로 분할
분할된 책임을 수행할수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾기
해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 하기


역할
역할의 개념이 애매했는데 이번에 정리됨

역할은 협력안에서 같은 책임을 수행할수 있는 객체들을 바꿔낄수 있는 슬롯

즉 협력 안에서 객체들간의 의사소통 구조로 표현하지만

이 책임을 수행할 객체가 여려개고 분기로 갈리게 되는 상황이 존재할수 있음

이때 이 책임을 수행할 자리를 객체로 표현하는것이 아닌 역할로 표현하는것

즉 인터페이스, 추상화			


# Summary

## Intro
- 잘 설계된 객체지향 App은 낮은 결합도, 높은 응집도(`low coupling high cohesion`)
- 객체가 명확하게 한가지 일만 잘 하는 객체인가?(`SRP`)
- `SRP`는 필연적으로 객체간 많은 커뮤니케이션을 유도
- 커뮤니케이션 == 의존성
- 의존성 == 결합도
- 과도한 의존성은 `OCP`를 위배케함(`tight coupling`)
    - 의존성 : 의존하는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있음을 의미
- 객체지향 설계란 의존성을 관리하는것, 객체가 변화를 받아들일수 있게 의존성을 정리하는 기술!(`lead to loose coupling`)
    - 결국 재사용성과 변경 용이성이 핵심

## 1. 의존성 이해하기

### '의존성' 이란 워딩에 대해 - vs 의존관계

![첨부 이미지](https://jinia-img-bucket.s3.ap-northeast-2.amazonaws.com/03c1237f-668e-48b9-83d0-9a2bbadb3626.png)

[UML에서 말하는 의존 관계]

- 의존성(`Dependency`)는 UML 상의 의존 관계(`Dependency Relationship`)과는 다른 관점/개념
- 의존성은 UML 상의 관계`'Relationship`) 전체를 포괄하는 개념으로 이해



### 간접 의존성과 의존성 전이

>A객체가 B객체를 알고있고, B객체가 C 객체를 알고있다

=> 간단한 3단논법처럼 `A객체는 C객체를 알수'도' 있다.`

의존성이 전파되는 여부는 B객체가 C객체를 얼마나 캡슐화 하느냐에 따라 다름!





### 명시적 의존성과 묵시적 의존성

객체 내부에서 의존하는 객체의 생성주기를 관여하게되면 묵시적 의존성이 생기고, 묵시적 의존성은 결국 의존성 파악을 위해 내부 구현을 확인해야하는 일이 생김!

따라서 묵시적 의존성을 피하고 의존성을 명시하는 코드가 더 좋은코드다!

명시적 의존성을 표현하기 위해서는?

의존성을 주입해주는것이 가장 바람직!

의존성을 주입해주면 내부 구현을 보지 않고도 해당 객체가 어떤 의존성을 가지는지 `Public Interface`를 통해 노출됨

> `sudoController.setterService(new ConcreteService());`

- `sudozController가 ConcreteService를 의존하고있구나! 라고 정확히 파악 가능`


### 위의 논리로 NEW는 해롭다
- `new`를 잘못 사용하면 클래스 사이의 결합도가 극단적으로 높아진다
- `new` 연산자를 사용하면 구체클라스를 노출, 인자도 모두 노출하므로 결합도가 지나치게 높아지게됨



# 유연한 설계

## `OCP`

### 런타임 의존성 컴파일 의존성

> 정적타입언어에서 더 잘 설명되는 개념

#### 런타임 의존성

- 애플리케이션이 실행되는 시점에 생기는 의존성
- 객체간 의존성
 
#### 컴파일 의존성

- 코드 그자체, 코드단위 의존성
- 클래스간 의존성

`Invoker` 와 `Reciever` 두 객체간 커뮤니케이션 상황에서, 다형성을 적용해 `Invoker`가 `Receiver` 추상 클래스를 바라보는 의존성을 만들었다면, 

컴파일 의존성 시점에서는 `Invoker`는 구체적 `Reciever`를 알지 못할 것이다.

하지만 런타임시점에서는 구체적 `Reciever`를 의존관계 주입을 통해 받게 되므로,  `Invoker`와 `Concrete Reciever`간 의존성이 생기게 된다.

### 의존성 해결하기

- 간접의존성은 최소화,
- 컴파일 의존성은 추상적으로
- 구체적 구현체에 대한 의존성은 런타임 시점으로 교체하기(의존성 주입 방법)
    - 객체를 생성하는 시점에 생성자를 통해 의존성 해결
    - 객체 생성 후 setter메서드를 통해 의존성 해결
    - 메서드 실행시 인자를 이용해 의존성 해결

- 스프링 의존성 주입(`DI`) 전략과 동일!

### 추상화가 핵심

## 생성 사용 분리

> 객체의 생성은 어디에서 하는것이 가장 바람직한가? 생성과 사용을 분리(`separating use from creation`)

> 소프트웨어 시스템은 (응용 프로그램 객체를 제작하고 의존성을 서로 연결하는) 시작단계와 (시작 이후에 이어지는) 실행 단계를 분리해야한다 


### Sol 1. 객체의 생성 책임을 클라이언트에게

> A 클라이언트가 context를 갖고 있으며, B객체에게 메시지를 전달할때,  B객체가 C객체의 생성과 사용 책임을 갖고있는경우, C객체의 생성 책임을 A객체에게 주고, B객체에겐 C객체를 인자로 전달하는 방법

### Sol 2. Factory 추가하기
> 만약 A 클라이언트에게 context를 주기 싫다면?

- 객체 생성만 전담하는 Factory 객체를 만들어 해결하기!
- `Factory`는 `Pure Fabrication`
    - 객체지향이 실세계의 모방이라는 말이 틀린이유!
    - 객체지향은 설계자들이 임의적으로 창조한 인공적인 추상화들을 포함하고있고, 오히려 그런 개념이 더 많은 비중을 차지한다.

## 의존성 주입(`DI`)

>사용할 객체 생성 책임을 다른 객체에게 전가한다는것은, 해당 의존성을 외부에서 주입받는다는 것

- 생성자 주입
- setter 주입
- 메서드 주입


## DIP

- `Seperated Interface` 패턴
- 객체를 인터페이스와 구현으로 분리한 후, 인터페이스를 서버 모듈이 들고있는것이 아닌, 클라이언트 모듈이 들고있게하여 의존성 방향을 역전시키는 것



## 유연한 설계는 유연성이 필요할때만 옳다

- 유연한 설계와 단순하고 명료한 설계는 정 반대의 길
- 유연한 설계라는것은 복잡한 설계를 의미
- **정말 유연성이 필요한 부분인가?!**
- 불필요한 유연성은 불필요한 복잡성을 낳는다


> 인간의 지적 능력은 정적인 관계에 더 잘 들어맞고, 시간에 따른 진행과정을 시각화하는 능력은 덜 발달되있다. 이러한 이유로 우리는 정적인 프로그램과 동적인 프로세스 사이의 간극을 줄이기 위해 최선을 다해야하며, 이를 통해 프로그램과 진행과정 사이를 가능한 일치시켜야한다. - Dijkstra





중복여부를 결정하는 기준은 코드가 변경에 반응하는 방식이며, 변경해야 할 이유가 같다면 두 코드는 중복이다.

코드 모양이 비슷하다고 코드의 중복이라고 생각해서는 안된다!

변경이유가 같은것이 코드의 중복!

dry 원칙, Once and Only Once 원칙, 단일 지점 제어 원칙(Single Point Control)


(타입 코드) 를 사용하는 클래스는 낮은 응집도, 높은 결합도의 문제를 시달리게됨

타입 코드는 필연적으로 타입에 따라 사용하지 않는 필드를 가지게 되고, 사용하지 않는 메서드를 가지게 되며, 이는 낮은 응집도, 그리고 여러 타입에 따른 다양한 의존성을 하나에 모이게 되면서 높은 결합도를 가지게 됨

요구사항과 구현의 차이가 클수록 코드를 이해하기가 힘들어진다

요구사항은 유즈케이스 -> 코드는 비즈니스 로직을 담는것이 근본적인 목적 -> 비즈니스로직과 구현이 차이가 날수록 직관성에서 멀어지고, 코드를 이해하기가 더 어려워짐 -> 상속은 부모클래스와 자식클래스가 강결합되어있으므로, 자식클래스를 사용하는 비즈니스로직이 부모클래스의 코드제약에 제한받게 되고, 코드가 복잡해짐 -> 요구사항과 구현이 차이가 생기고 이는 코드를 이해하기 어려워짐
 

## 취약한 기반클래스 문제(Fragile Base Class Problem, Brittle Base Case Problem)


> 상속을 위한 경고 1
    > 자식 클래스의 메서드 안에서 super참조를 이용해 부모클래스의 메서드를 직접 호출할 경우, 두 클래스는 강하게 결합되므로 super호출을 제거할수 있는 방법을 찾아 결합도를 제거하라


> 상속을 위한 경고 2
> 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨뜨릴수도 있다.


> 상속을 위한 경고 3
> 자식 클래스가 부모클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.


> 상속을 위한 경고 4
> 클래스를 상속하면 결합도로 인해 자식 클래스와 부모클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘중 하나를 선택할 수 밖에 없다.



상속과 합성의 가장 큰 차이점은 상속은 부모클래스를 컴파일시점에 참조하지만, 합성은 런타임시점에 참조가능하다는것!

즉 코드단위에서는 참조를 상위 추상화에 하고, 런타임시점에 구현체에 의존하게하므로서 결합도를 낮출수 있다.

-> 상속은  whiteBox Reuse
-> 합성은  blackBox Reuse
[GOF DP]



믹스인 -> 다중 상속 -> 컴파일시점에 다중상속하기!



### 합성은 조합을 통해 불필요한 클래스 생성을 방지할수 있음



## 다형성의 CS적 정의


![첨부 이미지](https://jinia-img-bucket.s3.ap-northeast-2.amazonaws.com/7e4955bf-8439-4e23-9de2-d39b47fece3d.png)



- 제네릭 프로그래밍
- 서브타입 다형성
- 오버로딩 다형성
- 강제 다형성 -> 언어차원에서 지원해주는 다형성



## 올바르게 상속을 사용하기 위한 조건

1. 상속관계가 is-a 모델링을하는가
2. 클라이언트 입장에서 부모 클래스의 타입으로 자식클래스를 사용해도 무방한가
    - 리스코프원칙을 준수하는가
    - 행동 호환성의 문제

실무적인 관점에서 2번을 통해 체크하는것이 훨씬 이해하기 쉬움

is-a 새 - 펭귄

새는 날수 있는데 펭귄은 못남 ㅇㅇ

is-a를 단편적으로, 글자 그대로 받아들이면 자연어의 모호함에 빠져 오개념을 가질수 있음

is-a는 적절하지 못하다!

클라이언트 입장에서 행동호환이 되는가, 동일 메시지 -> 클라이언트가 문맥에 맞는결과를 항상 얻을수 있는가

인터페이스는 결국 클라이언트가 기대하는 바에 따라 분리되어야한다!

=> 이것이 곧 `ISP`


인터페이스를 나누는 기준은 client 관점에서 생각하는것이 실무적이고 유용한 판단!

객체지향이 현실을 그대로 코드로 옮긴다던가, 자연어에 대한 모호함에 기대며 이해하는것은 OOP에 대한 잘못된 접근법


> 클라이언트와 격리한채로 본 모델은 의미있게 검증하는 것이 불가능하다

어떤 모델의 유효성은 클라이언트 관점에서만 검증가능한것

LSP 위반은 잠재적인 OCP 위반



클라이언트 - 서버와의 관계는 협력을 의무와 이익으로 구성된 계약관점에서 계약에 의한  설계(`DBC`) 라고 칭하기도함

d!

결국 클라이언트의 문맥에 맞는 결과를 얻는다는것은 상속 여부를 해당 타입을 사용하는 문맥-도메인-비즈니스에 강결합하여 생각해야하고

문맥에 따른 검증은 테스트코드를 통한 비즈니스 명세로 정의하는것이 좋을듯?
